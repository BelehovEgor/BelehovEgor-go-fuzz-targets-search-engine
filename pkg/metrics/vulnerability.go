package metrics

import (
	"go/ast"
	"go/token"
	"go/types"
	"reflect"

	myAst "github.com/BelehovEgor/go-fuzz-targets-search-engine/pkg/ast"
	"golang.org/x/tools/go/packages"
)

type Vulnerability struct {
	// Func info
	Package string
	Name    string

	// Dependency
	numbers_of_parameter_variables                         int
	numbers_of_variables_as_parameters_for_callee_function int

	// Pointers
	numbers_of_pointer_arithmetic                       int
	numbers_of_variables_involved_in_pointer_arithmetic int
	max_pointer_arithmetic_a_variable_is_involved_in    int

	// Control Structures
	numbers_of_nested_control_structures                int
	max_nesting_level_of_control_structures             int
	max_of_control_dependent_control_structures         int
	max_of_data_dependent_control_structures            int
	numbers_of_if_structures_without_else               int
	numbers_of_variables_involved_in_control_predicates int
}

func (vuln Vulnerability) GetPackage() string {
	return vuln.Package
}

func (vuln Vulnerability) GetName() string {
	return vuln.Name
}

func (vuln Vulnerability) GetScore() int {
	return vuln.numbers_of_parameter_variables +
		vuln.numbers_of_variables_as_parameters_for_callee_function +
		vuln.numbers_of_pointer_arithmetic +
		vuln.numbers_of_variables_involved_in_pointer_arithmetic +
		vuln.max_pointer_arithmetic_a_variable_is_involved_in +
		vuln.numbers_of_nested_control_structures +
		vuln.max_nesting_level_of_control_structures +
		vuln.max_of_control_dependent_control_structures +
		vuln.max_of_data_dependent_control_structures +
		vuln.numbers_of_if_structures_without_else +
		vuln.numbers_of_variables_involved_in_control_predicates
}

func CalculateVulnerabilities(pkg *packages.Package) ([]Rankable, error) {
	var complexity = make([]Rankable, 0)
	for _, target := range myAst.GetFuncs(pkg) {
		dimension, err := calculateVulnerability(target, pkg)
		if err != nil {
			return nil, err
		}

		complexity = append(complexity, dimension)
	}

	return complexity, nil
}

func CalculateVulnerability(pkg *packages.Package, funcName string) (*Vulnerability, error) {
	targetFunc, err := myAst.GetFunc(pkg, funcName)
	if err != nil {
		return nil, err
	}

	return calculateVulnerability(targetFunc, pkg)
}

func calculateVulnerability(funcDecl *ast.FuncDecl, pkg *packages.Package) (*Vulnerability, error) {
	var vulnerability *Vulnerability = &Vulnerability{
		Package: pkg.PkgPath,
		Name:    funcDecl.Name.Name,
	}

	vulnerability.numbers_of_parameter_variables = inDependencyMetric(funcDecl)
	vulnerability.numbers_of_variables_as_parameters_for_callee_function = outDependencyMetric(funcDecl)

	vulnerability.numbers_of_pointer_arithmetic,
		vulnerability.numbers_of_variables_involved_in_pointer_arithmetic,
		vulnerability.max_pointer_arithmetic_a_variable_is_involved_in = countNumbersOfPointerArithmetic(funcDecl, pkg.TypesInfo.Types)

	vulnerability.numbers_of_nested_control_structures = numbersOfNestedControlStructures(funcDecl)
	vulnerability.max_nesting_level_of_control_structures = maxNestingLevelOfControlStructures(funcDecl)
	vulnerability.max_of_control_dependent_control_structures = maxOfControlDependentControlStructures(funcDecl)

	vulnerability.max_of_data_dependent_control_structures,
		vulnerability.numbers_of_variables_involved_in_control_predicates = maxOfDataDependentControlStructures(funcDecl, pkg.TypesInfo.Types)
	vulnerability.numbers_of_if_structures_without_else = numbersOfIfStructuresWithoutElse(funcDecl)

	return vulnerability, nil
}

func inDependencyMetric(funcDecl *ast.FuncDecl) int {
	return len(funcDecl.Type.Params.List)
}

func outDependencyMetric(funcDecl *ast.FuncDecl) int {
	return countOutDependencies(funcDecl.Body)
}

func countOutDependencies(body *ast.BlockStmt) int {
	if body == nil {
		return 0
	}

	varAsArg := make(map[string]bool)

	ast.Inspect(body, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.CallExpr:
			for _, arg := range x.Args {
				extractIdentifiersFromExpr(arg, varAsArg)
			}
		}

		return true
	})

	return len(varAsArg)
}

func countNumbersOfPointerArithmetic(
	fdecl *ast.FuncDecl,
	exprTypes map[ast.Expr]types.TypeAndValue) (int, int, int) {
	if fdecl == nil || fdecl.Body == nil {
		return 0, 0, 0
	}

	count := 0
	usedVariables := make(map[string]bool, 0)
	maxUsedVariables := 0
	ast.Inspect(fdecl.Body, func(node ast.Node) bool {
		switch x := node.(type) {
		case *ast.IncDecStmt:
			if isUintptr(x.X, exprTypes) {
				count++
				vars := getExprVariables(x.X, exprTypes)
				maxUsedVariables = max(maxUsedVariables, len(vars))
				for name := range vars {
					usedVariables[name] = true
				}
			}
		case *ast.AssignStmt:
			vars := make(map[string]bool, 0)
			pointerOp := false
			for _, lhs := range x.Lhs {
				if isUintptr(lhs, exprTypes) && x.Tok != token.ASSIGN {
					for value := range getExprVariables(lhs, exprTypes) {
						vars[value] = true
					}
					pointerOp = true
				}
			}
			for _, rhs := range x.Rhs {
				if isUintptr(rhs, exprTypes) {
					for value := range getExprVariables(rhs, exprTypes) {
						vars[value] = true
					}
					pointerOp = true
				}
			}

			if pointerOp {
				for name := range vars {
					usedVariables[name] = true
				}
				maxUsedVariables = max(maxUsedVariables, len(vars))

				count++
			}

		case *ast.CallExpr:
			fun, ok := x.Fun.(*ast.Ident)
			if !ok || fun.Name == "" {
				updatedCount := count + 1
				for _, arg := range x.Args {
					if isUintptr(arg, exprTypes) || isPointer(arg, exprTypes) {
						vars := getExprVariables(arg, exprTypes)
						maxUsedVariables = max(maxUsedVariables, len(vars))
						for name := range vars {
							usedVariables[name] = true
						}
						count = updatedCount
					}
				}
			}
		}

		return true
	})
	return count, len(usedVariables), maxUsedVariables
}

func isUintptr(expr ast.Expr, exprTypes map[ast.Expr]types.TypeAndValue) bool {
	exprType, ok := exprTypes[expr]
	if ok {
		basic, ok := exprType.Type.(*types.Basic)

		return ok && basic.Kind() == types.Uintptr
	}

	return false
}

func isPointer(expr ast.Expr, exprTypes map[ast.Expr]types.TypeAndValue) bool {
	exprType, ok := exprTypes[expr]
	if ok {
		basic, ok := exprType.Type.(*types.Basic)

		return ok && basic.Kind() == types.UnsafePointer
	}

	return false
}

func numbersOfNestedControlStructures(fdecl *ast.FuncDecl) int {
	count := 0
	if fdecl == nil || fdecl.Body == nil {
		return count
	}

	ast.Inspect(fdecl.Body, func(node ast.Node) bool {
		switch node.(type) {
		case *ast.ForStmt, *ast.IfStmt, *ast.SwitchStmt, *ast.SelectStmt:
			count++
		}
		return true
	})
	return count
}

func maxNestingLevelOfControlStructures(fdecl *ast.FuncDecl) int {
	if fdecl == nil || fdecl.Body == nil {
		return 0
	}

	level := 0
	maxLevel := 0
	myAst.Inspect(
		fdecl.Body,
		func(node ast.Node) {
			switch node.(type) {
			case *ast.ForStmt, *ast.IfStmt, *ast.SwitchStmt, *ast.SelectStmt:
				level++
				if level > maxLevel {
					maxLevel = level
				}
			}
		},
		func(node ast.Node) bool {
			return true
		},
		func(node ast.Node) {
			switch node.(type) {
			case *ast.ForStmt, *ast.IfStmt, *ast.SwitchStmt, *ast.SelectStmt:
				level--
			}
		})
	return maxLevel
}

func maxOfControlDependentControlStructures(fdecl *ast.FuncDecl) int {
	if fdecl == nil || fdecl.Body == nil {
		return 0
	}

	maxCount := 0
	level := 0
	count := 0
	myAst.Inspect(
		fdecl.Body,
		func(node ast.Node) {
			switch node.(type) {
			case *ast.ForStmt, *ast.IfStmt, *ast.SwitchStmt, *ast.SelectStmt:
				level++
				count++
			}
		},
		func(node ast.Node) bool {
			return true
		},
		func(node ast.Node) {
			switch node.(type) {
			case *ast.ForStmt, *ast.IfStmt, *ast.SwitchStmt, *ast.SelectStmt:
				level--
				if level == 0 {
					maxCount = max(count, maxCount)
					count = 0
				}
			}
		})
	return maxCount
}

func maxOfDataDependentControlStructures(fdecl *ast.FuncDecl, exprTypes map[ast.Expr]types.TypeAndValue) (int, int) {
	if fdecl == nil || fdecl.Body == nil {
		return 0, 0
	}

	count := 0
	usedVariables := make(map[string]bool, 0)
	dataVariables := make(map[string]bool, 0)
	ast.Inspect(
		fdecl.Type.Params,
		func(node ast.Node) bool {
			switch x := node.(type) {
			case *ast.Field:
				for _, name := range x.Names {
					dataVariables[name.Name] = true
				}
				return false
			}
			return true
		})

	ast.Inspect(
		fdecl.Body,
		func(node ast.Node) bool {
			switch x := node.(type) {
			case *ast.AssignStmt:
				hasDataDependent := false
				for i := range x.Rhs {
					for name := range getExprVariables(x.Rhs[i], exprTypes) {
						if dataVariables[name] {
							hasDataDependent = true
							break
						}
					}
				}
				if hasDataDependent {
					for i := range x.Lhs {
						if lhs, ok := x.Lhs[i].(*ast.Ident); ok {
							dataVariables[lhs.Name] = true
						}
					}
				}

			case *ast.ForStmt:
				if doesPredicateDepend(x.Cond, dataVariables, exprTypes) {
					count++
				}
				for name := range getExprVariables(x.Cond, exprTypes) {
					usedVariables[name] = true
				}
			case *ast.IfStmt:
				if doesPredicateDepend(x.Cond, dataVariables, exprTypes) {
					count++
				}
				for name := range getExprVariables(x.Cond, exprTypes) {
					usedVariables[name] = true
				}
			case *ast.SwitchStmt:
				if doesPredicateDepend(x.Tag, dataVariables, exprTypes) {
					count++
				}
				for name := range getExprVariables(x.Tag, exprTypes) {
					usedVariables[name] = true
				}
			}
			return true
		})

	return count, len(usedVariables)
}

func doesPredicateDepend(
	pred ast.Expr,
	dataVariables map[string]bool,
	exprTypes map[ast.Expr]types.TypeAndValue) bool {
	result := false
	if pred == nil {
		return result
	}

	ast.Inspect(pred, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.Ident:
			_, ok := exprTypes[x]
			if ok {
				if dataVariables[x.Name] {
					result = true
					return false
				}
			}
		}

		return true
	})

	return result
}

func getExprVariables(expr ast.Expr, exprTypes map[ast.Expr]types.TypeAndValue) map[string]bool {
	vars := make(map[string]bool, 0)
	if expr == nil {
		return vars
	}

	ast.Inspect(expr, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.Ident:
			xType, ok := exprTypes[x]
			if ok {
				mode := getPrivateField(xType, "mode")
				if mode == 5 { // var
					vars[x.Name] = true
				}
				return false
			}
		}

		return true
	})

	return vars
}

func getPrivateField(s types.TypeAndValue, fieldName string) byte {
	immutable := reflect.ValueOf(s)
	mode := immutable.FieldByName(fieldName)
	return byte(mode.Uint())
}

func numbersOfIfStructuresWithoutElse(fdecl *ast.FuncDecl) int {
	count := 0
	if fdecl == nil || fdecl.Body == nil {
		return 0
	}

	ast.Inspect(fdecl.Body, func(node ast.Node) bool {
		if stmt, ok := node.(*ast.IfStmt); ok && stmt.Else == nil {
			count++
		}
		return true
	})
	return count
}

func extractIdentifiersFromExpr(expr ast.Expr, variables map[string]bool) {
	ast.Inspect(expr, func(node ast.Node) bool {
		switch x := expr.(type) {
		case *ast.Ident:
			variables[x.Name] = true
		case *ast.CallExpr:
			for _, expr := range x.Args {
				extractIdentifiersFromExpr(expr, variables)
			}

			return false
		}

		return true
	})
}
