package metrics

import (
	"go/ast"
	"go/token"

	myAst "github.com/BelehovEgor/go-fuzz-targets-search-engine/pkg/ast"
)

type Vulnerability struct {
	// Func info
	Name string

	// Dependency
	numbers_of_parameter_variables                         int
	numbers_of_variables_as_parameters_for_callee_function int

	// Pointers
	numbers_of_pointer_arithmetic                       int
	numbers_of_variables_involved_in_pointer_arithmetic int
	max_pointer_arithmetic_a_variable_is_involved_in    int

	// Control Structures
	numbers_of_nested_control_structures                int
	max_nesting_level_of_control_structures             int
	max_of_control_dependent_control_structures         int
	max_of_data_dependent_control_structures            int
	numbers_of_if_structures_without_else               int
	numbers_of_variables_involved_in_control_predicates int
}

func CalculateVulnerabilities(code string) ([]*Vulnerability, error) {
	f, err := myAst.ParseFile(code)
	if err != nil {
		return nil, err
	}

	var complexity = make([]*Vulnerability, 0)
	for _, target := range myAst.FindFuncDecls(f) {
		dimension, err := calculateVulnerability(target)
		if err != nil {
			return nil, err
		}

		complexity = append(complexity, dimension)
	}

	return complexity, nil
}

func CalculateVulnerability(code string, funcName string) (*Vulnerability, error) {
	f, err := myAst.ParseFile(code)
	if err != nil {
		return nil, err
	}

	targetFunc, err := myAst.FindFuncDeclByName(f, funcName)
	if err != nil {
		return nil, err
	}

	return calculateVulnerability(targetFunc)
}

func calculateVulnerability(funcDecl *ast.FuncDecl) (*Vulnerability, error) {
	var vulnerability *Vulnerability = &Vulnerability{}

	vulnerability.numbers_of_parameter_variables = inDependencyMetric(funcDecl)
	vulnerability.numbers_of_variables_as_parameters_for_callee_function = outDependencyMetric(funcDecl)

	vulnerability.numbers_of_pointer_arithmetic = countNumbersOfPointerArithmetic(funcDecl)
	vulnerability.numbers_of_variables_involved_in_pointer_arithmetic = countNumbersOfVariablesInvolvedInPointerArithmetic(funcDecl)
	vulnerability.max_pointer_arithmetic_a_variable_is_involved_in = countMaxPointerArithmeticVariableIsInvolvedIn(funcDecl)

	vulnerability.numbers_of_nested_control_structures = numbersOfNestedControlStructures(funcDecl)
	vulnerability.max_nesting_level_of_control_structures = maxNestingLevelOfControlStructures(funcDecl)
	vulnerability.max_of_control_dependent_control_structures = maxOfControlDependentControlStructures(funcDecl)
	vulnerability.max_of_data_dependent_control_structures = maxOfDataDependentControlStructures(funcDecl)
	vulnerability.numbers_of_if_structures_without_else = numbersOfIfStructuresWithoutElse(funcDecl)
	vulnerability.numbers_of_variables_involved_in_control_predicates = numbersOfVariablesInvolvedInControlPredicates(funcDecl)

	return vulnerability, nil
}

func inDependencyMetric(funcDecl *ast.FuncDecl) int {
	return len(funcDecl.Type.Params.List)
}

func outDependencyMetric(funcDecl *ast.FuncDecl) int {
	return countOutDependencies(funcDecl.Body)
}

func countOutDependencies(body *ast.BlockStmt) int {
	varAsArg := make(map[string]bool)

	ast.Inspect(body, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.CallExpr:
			for _, arg := range x.Args {
				extractIdentifiersFromExpr(arg, varAsArg)
			}
		}

		return true
	})

	return len(varAsArg)
}

func countNumbersOfPointerArithmetic(funcDecl *ast.FuncDecl) int {
	numberOfPointerArithmeticOp := 0

	ast.Inspect(funcDecl, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.BinaryExpr:
			if isPointerArithmeticOp(x.Op) {
				numberOfPointerArithmeticOp++
			}
		}
		return true
	})

	return numberOfPointerArithmeticOp
}

func countNumbersOfVariablesInvolvedInPointerArithmetic(funcDecl *ast.FuncDecl) int {
	variablesMap := make(map[string]bool)
	ast.Inspect(funcDecl, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.BinaryExpr:
			if isPointerArithmeticOp(x.Op) {
				addVariableToMap(x.X, variablesMap)
				addVariableToMap(x.Y, variablesMap)
			}
		}
		return true
	})

	return len(variablesMap)
}

func countMaxPointerArithmeticVariableIsInvolvedIn(funcDecl *ast.FuncDecl) int {
	maxDepth := 0
	currentDepth := 0

	myAst.Inspect(funcDecl,
		func(n ast.Node) {
			switch x := n.(type) {
			case *ast.BinaryExpr:
				if isPointerArithmeticOp(x.Op) {
					currentDepth++
					if currentDepth > maxDepth {
						maxDepth = currentDepth
					}
				}
			}
		},
		func(n ast.Node) bool {
			return true
		},
		func(n ast.Node) {
			switch x := n.(type) {
			case *ast.BinaryExpr:
				if isPointerArithmeticOp(x.Op) {
					currentDepth--
				}
			}
		})

	return maxDepth
}

func numbersOfNestedControlStructures(fdecl *ast.FuncDecl) int {
	count := 0
	ast.Inspect(fdecl.Body, func(node ast.Node) bool {
		switch node.(type) {
		case *ast.ForStmt, *ast.IfStmt, *ast.SwitchStmt, *ast.SelectStmt:
			count++
		}
		return true
	})
	return count
}

func maxNestingLevelOfControlStructures(fdecl *ast.FuncDecl) int {
	level := 0
	maxLevel := 0
	ast.Inspect(fdecl.Body, func(node ast.Node) bool {
		switch node.(type) {
		case *ast.ForStmt, *ast.IfStmt, *ast.SwitchStmt, *ast.SelectStmt:
			level++
			if level > maxLevel {
				maxLevel = level
			}
		case *ast.BlockStmt:
			level--
		}
		return true
	})
	return maxLevel
}

func maxOfControlDependentControlStructures(fdecl *ast.FuncDecl) int {
	maxCount := 0
	count := 0
	ast.Inspect(fdecl.Body, func(node ast.Node) bool {
		switch node.(type) {
		case *ast.ForStmt, *ast.IfStmt, *ast.SwitchStmt, *ast.SelectStmt:
			count++
			if count > maxCount {
				maxCount = count
			}
		case *ast.BlockStmt:
			count = 0
		}
		return true
	})
	return maxCount
}

func maxOfDataDependentControlStructures(fdecl *ast.FuncDecl) int {
	maxCount := 0
	count := 0
	ast.Inspect(fdecl.Body, func(node ast.Node) bool {
		switch node.(type) {
		case *ast.IfStmt:
			count++
			if count > maxCount {
				maxCount = count
			}
		case *ast.BlockStmt:
			count = 0
		}
		return true
	})
	return maxCount
}

func numbersOfIfStructuresWithoutElse(fdecl *ast.FuncDecl) int {
	count := 0
	ast.Inspect(fdecl.Body, func(node ast.Node) bool {
		if stmt, ok := node.(*ast.IfStmt); ok && stmt.Else == nil {
			count++
		}
		return true
	})
	return count
}

func numbersOfVariablesInvolvedInControlPredicates(fdecl *ast.FuncDecl) int {
	variables := make(map[string]bool)
	ast.Inspect(fdecl.Body, func(node ast.Node) bool {
		switch node.(type) {
		case *ast.IfStmt, *ast.ForStmt, *ast.RangeStmt:
			inspectCondition(node, variables)
		}
		return true
	})
	return len(variables)
}

func inspectCondition(node ast.Node, variables map[string]bool) {
	switch cond := node.(type) {
	case *ast.IfStmt:
		extractIdentifiersFromExpr(cond.Cond, variables)
	case *ast.ForStmt:
		if cond.Init != nil {
			extractIdentifiersFromStmt(cond.Init, variables)
		}
		extractIdentifiersFromExpr(cond.Cond, variables)
		if cond.Post != nil {
			extractIdentifiersFromStmt(cond.Post, variables)
		}
	case *ast.RangeStmt:
		extractIdentifiersFromExpr(cond.Key, variables)
		extractIdentifiersFromExpr(cond.Value, variables)
	}
}

func extractIdentifiersFromStmt(expr ast.Stmt, variables map[string]bool) {
	ast.Inspect(expr, func(node ast.Node) bool {
		if ident, ok := node.(*ast.Ident); ok {
			variables[ident.Name] = true
		}
		return true
	})
}

func extractIdentifiersFromExpr(expr ast.Expr, variables map[string]bool) {
	ast.Inspect(expr, func(node ast.Node) bool {
		switch x := expr.(type) {
		case *ast.Ident:
			variables[x.Name] = true
		case *ast.CallExpr:
			for _, expr := range x.Args {
				extractIdentifiersFromExpr(expr, variables)
			}

			return false
		}

		return true
	})
}

func isPointerArithmeticOp(op token.Token) bool {
	return op == token.ADD || op == token.SUB
}

func addVariableToMap(expr ast.Expr, variablesMap map[string]bool) {
	switch x := expr.(type) {
	case *ast.Ident:
		variablesMap[x.Name] = true
	}
}
