package metrics

import (
	"go/ast"

	myAst "github.com/BelehovEgor/go-fuzz-targets-search-engine/pkg/ast"
)

type Vulnerability struct {
	// Func info
	Name string

	// Dependency
	numbers_of_parameter_variables                         int
	numbers_of_variables_as_parameters_for_callee_function int

	// Pointers
	//numbers_of_pointer_arithmetic                       int
	//numbers_of_variables_involved_in_pointer_arithmetic int
	//max_pointer_arithmetic_a_variable_is_involved_in    int

	// Control Structures
	numbers_of_nested_control_structures        int
	max_nesting_level_of_control_structures     int
	max_of_control_dependent_control_structures int
	//max_of_data_dependent_control_structures            int
	numbers_of_if_structures_without_else int
	//numbers_of_variables_involved_in_control_predicates int
}

func CalculateVulnerabilities(code string) ([]*Vulnerability, error) {
	f, err := myAst.ParseFile(code)
	if err != nil {
		return nil, err
	}

	var complexity = make([]*Vulnerability, 0)
	for _, target := range myAst.FindFuncDecls(f) {
		dimension, err := calculateVulnerability(target)
		if err != nil {
			return nil, err
		}

		complexity = append(complexity, dimension)
	}

	return complexity, nil
}

func CalculateVulnerability(code string, funcName string) (*Vulnerability, error) {
	f, err := myAst.ParseFile(code)
	if err != nil {
		return nil, err
	}

	targetFunc, err := myAst.FindFuncDeclByName(f, funcName)
	if err != nil {
		return nil, err
	}

	return calculateVulnerability(targetFunc)
}

func calculateVulnerability(funcDecl *ast.FuncDecl) (*Vulnerability, error) {
	var vulnerability *Vulnerability = &Vulnerability{}

	vulnerability.numbers_of_parameter_variables = inDependencyMetric(funcDecl)
	vulnerability.numbers_of_variables_as_parameters_for_callee_function = outDependencyMetric(funcDecl)

	//vulnerability.numbers_of_pointer_arithmetic = countNumbersOfPointerArithmetic(funcDecl)
	//vulnerability.numbers_of_variables_involved_in_pointer_arithmetic = countNumbersOfVariablesInvolvedInPointerArithmetic(funcDecl)
	//vulnerability.max_pointer_arithmetic_a_variable_is_involved_in = countMaxPointerArithmeticVariableIsInvolvedIn(funcDecl)

	vulnerability.numbers_of_nested_control_structures = numbersOfNestedControlStructures(funcDecl)
	vulnerability.max_nesting_level_of_control_structures = maxNestingLevelOfControlStructures(funcDecl)
	vulnerability.max_of_control_dependent_control_structures = maxOfControlDependentControlStructures(funcDecl)
	//vulnerability.max_of_data_dependent_control_structures = maxOfDataDependentControlStructures(funcDecl)
	vulnerability.numbers_of_if_structures_without_else = numbersOfIfStructuresWithoutElse(funcDecl)
	//vulnerability.numbers_of_variables_involved_in_control_predicates = numbersOfVariablesInvolvedInControlPredicates(funcDecl)

	return vulnerability, nil
}

func inDependencyMetric(funcDecl *ast.FuncDecl) int {
	return len(funcDecl.Type.Params.List)
}

func outDependencyMetric(funcDecl *ast.FuncDecl) int {
	return countOutDependencies(funcDecl.Body)
}

func countOutDependencies(body *ast.BlockStmt) int {
	varAsArg := make(map[string]bool)

	ast.Inspect(body, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.CallExpr:
			for _, arg := range x.Args {
				extractIdentifiersFromExpr(arg, varAsArg)
			}
		}

		return true
	})

	return len(varAsArg)
}

func countNumbersOfPointerArithmetic(fdecl *ast.FuncDecl) int {
	return 0
}

func numbersOfNestedControlStructures(fdecl *ast.FuncDecl) int {
	count := 0
	ast.Inspect(fdecl.Body, func(node ast.Node) bool {
		switch node.(type) {
		case *ast.ForStmt, *ast.IfStmt, *ast.SwitchStmt, *ast.SelectStmt:
			count++
		}
		return true
	})
	return count
}

func maxNestingLevelOfControlStructures(fdecl *ast.FuncDecl) int {
	level := 0
	maxLevel := 0
	myAst.Inspect(
		fdecl.Body,
		func(node ast.Node) {
			switch node.(type) {
			case *ast.ForStmt, *ast.IfStmt, *ast.SwitchStmt, *ast.SelectStmt:
				level++
				if level > maxLevel {
					maxLevel = level
				}
			}
		},
		func(node ast.Node) bool {
			return true
		},
		func(node ast.Node) {
			switch node.(type) {
			case *ast.ForStmt, *ast.IfStmt, *ast.SwitchStmt, *ast.SelectStmt:
				level--
			}
		})
	return maxLevel
}

func maxOfControlDependentControlStructures(fdecl *ast.FuncDecl) int {
	maxCount := 0
	level := 0
	count := 0
	myAst.Inspect(
		fdecl.Body,
		func(node ast.Node) {
			switch node.(type) {
			case *ast.ForStmt, *ast.IfStmt, *ast.SwitchStmt, *ast.SelectStmt:
				level++
				count++
			}
		},
		func(node ast.Node) bool {
			return true
		},
		func(node ast.Node) {
			switch node.(type) {
			case *ast.ForStmt, *ast.IfStmt, *ast.SwitchStmt, *ast.SelectStmt:
				level--
				if level == 0 {
					maxCount = max(count, maxCount)
					count = 0
				}
			}
		})
	return maxCount
}

func maxOfDataDependentControlStructures(fdecl *ast.FuncDecl) int {
	return 0
}

func numbersOfIfStructuresWithoutElse(fdecl *ast.FuncDecl) int {
	count := 0
	ast.Inspect(fdecl.Body, func(node ast.Node) bool {
		if stmt, ok := node.(*ast.IfStmt); ok && stmt.Else == nil {
			count++
		}
		return true
	})
	return count
}

func numbersOfVariablesInvolvedInControlPredicates(fdecl *ast.FuncDecl) int {
	return 0
}

func extractIdentifiersFromExpr(expr ast.Expr, variables map[string]bool) {
	ast.Inspect(expr, func(node ast.Node) bool {
		switch x := expr.(type) {
		case *ast.Ident:
			variables[x.Name] = true
		case *ast.CallExpr:
			for _, expr := range x.Args {
				extractIdentifiersFromExpr(expr, variables)
			}

			return false
		}

		return true
	})
}
